##### **经典题目**

- [x] **[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)【简单】**

```
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
```

- [x] **[合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)【简单】**

```
给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
说明:
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
示例:
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
输出: [1,2,2,3,5,6]
```

- [x] **[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)【简单】**

```
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。
示例 1:
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

- [x] [验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)【简单】

```
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1:
输入: "A man, a plan, a canal: Panama"
输出: true
示例 2:
输入: "race a car"
输出: false
```

- [x] [二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)【中等】

```
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
示例：
二叉树：[3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

- [x] [复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)【中等】

```
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
要求返回这个链表的 深拷贝。 
我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
示例 1：
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
示例 2：
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
示例 3：
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
示例 4：
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
提示：
-10000 <= Node.val <= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 。
```

- [ ] [LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)【中等】

```
运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。
进阶:
你是否可以在 O(1) 时间复杂度内完成这两种操作？
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

- [ ] [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)【中等】

```
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1:
输入:
11110
11010
11000
00000
输出: 1
示例 2:
输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```

- [ ] [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)【困难】

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
示例:
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```

- [ ] [最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)【困难】

```
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。
示例：
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
说明：
如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。
```

##### **数组**

- [ ] [寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)【困难】
- [ ] [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)【中等】
- [x] [三数之和](https://leetcode-cn.com/problems/3sum/)【中等】

```
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

- [ ] [下一个排列](https://leetcode-cn.com/problems/next-permutation/)【中等】
- [ ] [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)【中等】
- [ ] [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)【中等】
- [ ] [螺旋数组](https://leetcode-cn.com/problems/spiral-matrix/)【中等】
- [ ] [合并区间](https://leetcode-cn.com/problems/merge-intervals/)【中等】
- [ ] [除自身之外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)【中等】
- [ ] [最后一块石头的重量II](https://leetcode-cn.com/problems/last-stone-weight-ii/)【中等】

##### **字符串**

- [ ] [整数转换英文表示](https://leetcode-cn.com/problems/integer-to-english-words/)【困难】
- [ ] [字符串相加](https://leetcode-cn.com/problems/add-strings/)【简单】
- [ ] [验证回文字符串II](https://leetcode-cn.com/problems/valid-palindrome-ii/)【简单】
- [ ] [最常见的单词](https://leetcode-cn.com/problems/most-common-word/)【简单】
- [ ] [重新排列日志文件](https://leetcode-cn.com/problems/reorder-data-in-log-files/)【简单】

##### **链表**

- [ ] [两数相加]( https://leetcode-cn.com/problems/add-two-numbers/ )【中等】
- [ ] [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)【中等】
- [ ] [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)【中等】
- [ ] [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)【简单】
- [ ] [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)【简单】

##### **堆与栈**

- [ ] [有效地括号](https://leetcode-cn.com/problems/valid-parentheses/)【简单】
- [ ] [会议室II](https://leetcode-cn.com/problems/meeting-rooms-ii/)【中等】
- [ ] [前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)【中等】
- [ ] [移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)【中等】

##### **哈希表**

- [ ] [两数之和](https://leetcode-cn.com/problems/two-sum/)【简单】
- [ ] [字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)【中等】
- [ ] [和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)【中等】
- [ ] [验证外星语词典](https://leetcode-cn.com/problems/verifying-an-alien-dictionary/)【简单】

##### **树**

- [ ] [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)【中等】
- [ ] [二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)【困难】
- [ ] [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)【中等】
- [ ] [二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)【中等】
- [ ] [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)【简单】
- [ ] [另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)【简单】

##### **分治算法**

- [ ] [合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)【困难】
- [ ] [数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)【中等】
- [ ] [搜索二维矩阵II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)【中等】
- [ ] [最接近原点的K个点](https://leetcode-cn.com/problems/k-closest-points-to-origin/)【中等】

##### **回溯算法**

- [ ] [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)【中等】
- [ ] [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)【中等】
- [ ] [全排列](https://leetcode-cn.com/problems/permutations/)【中等】
- [ ] [单词搜索](https://leetcode-cn.com/problems/word-search/)【中等】

##### **图论**

- [ ] [单词接龙](https://leetcode-cn.com/problems/word-ladder/)【中等】
- [ ] [火星词典](https://leetcode-cn.com/problems/alien-dictionary/)【困难】
- [ ] [删除无效的括号](https://leetcode-cn.com/problems/remove-invalid-parentheses/)【困难】
- [ ] [腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)【中等】
- [ ] [查找集群内的「关键连接」](https://leetcode-cn.com/problems/critical-connections-in-a-network/)【困难】

##### **动态规划**

- [ ] [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)【中等】
- [ ] [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)【中等】
- [ ] [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)【简单】
- [ ] [编辑距离](https://leetcode-cn.com/problems/edit-distance/)【困难】
- [ ] [单词拆分](https://leetcode-cn.com/problems/word-break/)【中等】
- [ ] [零钱兑换](https://leetcode-cn.com/problems/coin-change/)【中等】

##### **数学**

- [ ] [整数反转](https://leetcode-cn.com/problems/reverse-integer/)【简单】
- [ ] [字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)【中等】
- [ ] [二进制求和](https://leetcode-cn.com/problems/add-binary/)【简单】
- [ ] [快乐数](https://leetcode-cn.com/problems/happy-number/)【简单】

##### **设计**

- [ ] [数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)【困难】
- [ ] [二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)【困难】
- [ ] [常数时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)【中等】