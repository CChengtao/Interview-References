#### 1、二进制计数
小A刚学了二进制，他十分激动。为了确定他的确掌握了二进制，你给他出了这样一道题目：给定N个非负整数，将这N个数字按照二进制下1的个数分类，二进制下1的个数相同的数字属于同一类。求最后一共有几类数字？

**输入描述:**
输入的第一行是一个正整数T（0<T<=10），表示样例个数。对于每一个样例，第一行是一个正整数N（0<N<=100），表示有多少个数字。接下来一行是N个由空格分隔的非负整数，大小不超过2^31 – 1。，

**输出描述:**
对于每一组样例，输出一个正整数，表示输入的数字一共有几类。

**输入例子1:**

```
1
5
8 3 5 7 2
```

**输出例子1:**

```
3
```

**参考代码：**

```cpp
#include<iostream>
#include<set>
using namespace std;

int countOnes(int x) {
	int num = 0;
	while (x) {
		++num;
		x &= (x - 1);
	}
	return num;
}
int main() {
	int T;
	cin >> T;
	while (T--) {
		int N;
		cin >> N;
		set<int> container;
		while (N--){
			int x;
			cin >> x;
			int m = countOnes(x);
			if (container.find(m) == container.end()) container.insert(m);
		}
		cout << container.size() << endl;
	}
	return 0;
}
```

#### 2、水平线

伞屉国是一个以太阳能为主要发电手段的国家，因此他们国家中有着非常多的太阳能基站，链接着的基站会组合成一个发电集群。但是不幸的是伞屉国不时会遭遇滔天的洪水，当洪水淹没基站时，基站只能停止发电，同时被迫断开与相邻基站的链接。你作为伞屉国的洪水观察员，有着这样的任务：在洪水到来时，计算出发电集群被洪水淹没后被拆分成了多少个集群。

由于远古的宇宙战争的原因，伞屉文明是一个二维世界里的文明，所以你可以这样理解发电基站的位置与他们的链接关系：给你一个一维数组a，长度为n，表示了n个基站的位置高度信息。数组的第i个元素a[i]表示第i个基站的海拔高度是a[i],而下标相邻的基站才相邻并且建立链接，即x号基站与x-1号基站、x+1号基站相邻。特别的，1号基站仅与2号相邻，而n号基站仅与n-1号基站相邻。当一场海拔高度为y的洪水到来时，海拔高度小于等于y的基站都会被认为需要停止发电，同时断开与相邻基站的链接。

**输入描述:**

每个输入数据包含一个测试点。

第一行为一个正整数n，表示发电基站的个数 (0 < n <= 200000)

接下来一行有n个空格隔开的数字，表示n个基站的海拔高度，第i个数字a[i]即为第i个基站的海拔高度，对于任意的i(1<=i<=n),有(0 <= a[i] < 2^31-1)

接下来一行有一个正整数q(0 < q <= 200000)，表示接下来有q场洪水

接下来一行有q个整数，第j个整数y[j]表示第j场洪水的海拔为y[j],对于任意的j(1<=j<=n),有(-2^31 < y[j] < 2^31-1)

**输出描述:**
输出q行，每行一个整数，第j行的整数ans表示在第j场洪水中，发电基站会被分割成ans个集群。标准答案保证最后一个整数后也有换行。

**输入例子1:**

```
10
6 12 20 14 15 15 7 19 18 13 
6
15 23 19 1 17 24
```

**输出例子1:**

```
2
0
1
1
2
0
```

**参考代码(运行超时，通过40%)：**

```cpp
#include<iostream>
#include<vector>
using namespace std;

int main() {
	int n;
	int temp;
	cin >> n;
	vector<int> heighs;
	while (n--) {
		cin >> temp;
		heighs.push_back(temp);
	}
	int q;
	cin >> q;
	while (q--) {
		cin >> temp;
		int ans = 0;
		bool nei = false;
		for (const int& h : heighs) {
			if (h > temp) {
				if (!nei) {
					++ans;
					nei = true;
				}
			}
			else {
				nei = false;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```

#### 3、游泳池

小明作为一个游泳池管理员，以玩弄给水管和排水管为乐，也因此产生了很多数学题考验小朋友。

现在小明想把这个行动升级，考验一下程序员，做了一个自动装置来控制给水管和排水管。在开始时，给水管和排水管都是打开状态的，并且游泳池里没有水。在自动装置的作用下，每经过t1分钟，给水管的状态都会改变，即从打开状态变为关闭状态或从关闭状态变为打开状态，而同时每经过t2分钟，排水管的状态也会改变。当给水管打开时，给水管每分钟会向游泳池里注入m1升水；当排水管打开时，排水管每分钟会把游泳池里水排走m2升；当给水管和排水管同时打开时，游泳池的水量变化为每分钟(m1-m2)升。当然泳池的水量不能变为负数，同时泳池也有个最大容量m，水量不能超过m升。那么经过t分钟后，游泳池里有多少升水？

**输入描述:**

输入第一行为一个正整数T，表示有T组数据。

每组数据的为一行包含六个整数，分别表示m, t, m1, t1, m2, t2。

数据范围：

对于所有数据，满足1<=T<=10, 1<=m<=100000, 1<=t<=86400, 1<=m1,m2<=100, 1<=t1,t2<=10。

**输出描述:**
对于每一个数据，输出一行，包括一个整数，为在t分钟后游泳池中的水量。

**输入例子1:**

```
5
10 2 1 5 2 5
10 2 10 5 2 5
10 2 3 5 2 5
100 100 3 4 4 3
10000 1000 10 5 5 3
```

**输出例子1:**

```
0
10
2
3
2495
```

**参考代码：**

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

int main() {
	int T;
	cin >> T;
	while (T--) {
		int m, t, m1, t1, m2, t2;
		cin >> m >> t >> m1 >> t1 >> m2 >> t2;
		int ans = 0;
		for (int i = 0; i < t; ++i) {
			if ((i / t1) % 2 == 0) {
				ans += m1;
			}
			if ((i / t2) % 2 == 0) {
				ans -= m2;
			}
            ans = min(ans, m);
            ans = max(ans, 0);
		}
		cout << ans << endl;
	}
	return 0;
}
```




#### 4、幸运N串

小A很喜欢字母N，他认为连续的N串是他的幸运串。有一天小A看到了一个全部由大写字母组成的字符串，他被允许改变最多2个大写字母（也允许不改变或者只改变1个大写字母），使得字符串中所包含的最长的连续的N串的长度最长。你能帮助他吗？

**输入描述:**

输入的第一行是一个正整数T（0 < T <= 20），表示有T组测试数据。对于每一个测试数据包含一行大写字符串S（0 < |S| <= 50000，|S|表示字符串长度）。

**数据范围：**

20%的数据中，字符串长度不超过100；

70%的数据中，字符串长度不超过1000；

100%的数据中，字符串长度不超过50000。

**输出描述:**

对于每一组测试样例，输出一个整数，表示操作后包含的最长的连续N串的长度。

**输入例子1:**

```
3
NNTN
NNNNGGNNNN
NGNNNNGNNNNNNNNSNNNN
```

**输出例子1:**

```
4
10
18
```

**参看代码：**

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main() {
	int T;
	cin >> T;
	while (T--) {
		string temp;
		cin >> temp;
		int n = 0;
		int maxn = 0;
		int left = 0;
		int right = 0;
		int nonnum = 0;
		while (right < temp.length()) {
			if (temp[right] == 'N') {
				++n;
				++right;
				maxn = max(maxn, n);
			}
			else {
				++nonnum;
				if (nonnum > 2) {
					while (temp[left] == 'N') {
						++left;
						--n;
					}
					++left;
					--n;
					--nonnum;
				}
				++n;
				++right;
				maxn = max(maxn, n);
			}
		}
		cout << maxn;
	}
	return 0;
}

```

