#### 1. TCP 怎么保证可靠性

**（1）序列号、确认应答、超时重传**

数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。

**（2）窗口控制与高速重发控制/快速重传（重复确认应答）**

TCP 会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。

使用窗口控制，如果数据段1001-2000 丢失，后面数据每次传输，确认应答都会不停地发送序号为1001 的应答，表示我要接收1001 开始的数据，发送端如果收到3 次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......

**（3）拥塞控制**

如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP 在为了防止这种情况而进行了拥塞控制。

慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。

拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。

将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。快速重传：在遇到3 次重复确认应答（高速重发控制）时，代表收到了3 个报文段，但是这之前的1 个段丢失了，便对它进行立即重传。

然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3 的大小。这样可以达到：在TCP 通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。

#### 2. TCP 建立连接和断开连接的过程

<img src="..\images\网络连接.png" style="zoom: 80%;" />

**三次握手：**

（1）Client 将标志位SYN 置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT 状态，等待Server 确认；

（2）Server 收到数据包后由标志位SYN=1 知道Client 请求建立连接，Server 将标志位SYN和ACK 都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client 以确认连接请求，Server 进入SYN_RCVD 状态；

（3）Client 收到确认后，检查ack 是否为J+1，ACK 是否为1，如果正确则将标志位ACK 置为1，ack=K+1，并将该数据包发送给Server，Server 检查ack 是否为K+1，ACK 是否为1，如果正确则连接建立成功，Client Server 进入ESTABLISHED 状态，完成三次握手，随后Client 与Server 之间可以开始传输数据了。

**四次挥手：**

由于TCP 连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN 来终止这一方向的连接，收到一个FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP 连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

（1）数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1 状态，此时客户端依然可以接收服务器发送来的数据；

（2）服务器接收到FIN 后，发送一个ACK 给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT 状态。客户端收到后进入FIN_WAIT_2 状态；

（3）当服务器没有数据要发送时，服务器发送一个FIN 报文，此时服务器进入LAST_ACK 状态，等待客户端的确认；

（4）客户端收到服务器的FIN 报文后，给服务器发送一个ACK 报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT 状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

#### 3. TCP3次握手，4次断开的原因

**三次握手的原因**：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN 数据包在某个节点长期滞留。然后客户端又重传SYN 数据包并正确建立TCP 连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN 数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket 套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。

**四次挥手的原因**：由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN 包时，TCP 协议栈会直接发送一个ACK 确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN 包。应用层可以使用系统调用函数read==0 来判断对端是否关闭连接。

#### 4. TCP 的模型，状态转移

四层TCP/IP 模型如下：

<img src="..\images\四层TCP IP模型.png" style="zoom:67%;" />

其状态转移图如下：

![](..\images\TCP状态迁移图.png)

#### 5. OSI 七层模型和TCP/IP 四层模型，每层列举2 个协议

**OSI 七层模型及其包含的协议如下:**

物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45

数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP

网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP

传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP

会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS

表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII

应用层: 允许访问OSI 环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS

**TCP/IP 4 层模型包括：**

网络接口层：MAC VLAN

网络层:IP ARP ICMP

传输层:TCP UDP

应用层:HTTP DNS SMTP

#### 6. ARP和DNS的功能与区别

地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

#### 7. UDP怎么保证可靠性？

UDP 不属于连接性协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传输时使用 UDP 较多，因为它们即使偶尔丢失一两个包，也不会对接收结果产生太大影响。

传输层无法保证数据的可靠传输，只能通过应用层来实现，实现的方式可以参考 TCP 可靠性传输，只是实现不在传输层，实现转移到了**应用层**，**实现确认机制，重传机制，窗口确认机制**。

如果不利用 Linux 协议栈及上层 socket 机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现以下功能：

- 发送：包的分片、包确认、包的重发
- 接收：包的调序、包的序号确认
- 目前已有如下开源程序利用 UDP 实现了可靠的数据传输，分别为：RUDP、RTP、UDT