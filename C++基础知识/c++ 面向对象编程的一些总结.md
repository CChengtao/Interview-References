#### 1、面向对象特点

封装，继承，多态

#### 2、抽象类

抽象类是特殊的类，只是不能被实例化（将定义了纯虚函数的类称为抽象类）；除此以外，具有类的其他特性；抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。虽然不能定义抽象类的实例，但是可以定义它的指针，这正是用抽象类实现接口的重点所在。

```cpp
class animal{ 							//抽象类（有了纯虚函数才能成为抽象类）
public:
    virtual ~animal() = 0; 				//纯虚析构函数
    animal (int i = 0){x = i} 			//构造函数可有可无
    virtual void count(float a) = 0; 	//纯虚函数
protected:
    int x;								//保护类型，继承后可以被访问
}
```

总结：如果某个类不包含虚函数，那一般是表示它将不作为一个基类来使用。当一个类不准备作为基类使用时，就不要定义虚析构函数了，因为它会增加一个虚函数表，使得对象的体积翻倍，还有可能降低其可移值性。

#### 3、虚函数

C++实现运行中的多态性是通过虚函数实现的，而虚函数必须存在于继承环境下。

虚函数是重载的一种表现形式，是一种动态的重载方式。

只有类的普通成员函数可以定义为虚函数，非成员函数、静态成员函数（类拥有）、内联成员函数、构造函数及友元函数不能声明为虚函数。

只有用virtual声明类的成员函数，使之成为虚函数，不能将类外的普通函数声明为虚函数。因为虚函数的作用是允许在派生类中对基类的虚函数重新定义。所以虚函数只能用于类的继承层次结构中。

根据什么考虑是否把一个成员函数声明为虚函数？

① 看成员函数所在的类是否会作为基类

② 看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。

#### 4、纯虚函数

```cpp
virtual 函数类型 函数名（形参表列）= 0;
```

抽象类中定义的，为了派生类中的使用而声明定义的，其在基类中没有任何意义。含有纯虚函数的类不能实例化，只有在子类中才能实例化。

#### 5、虚析构函数 纯虚析构函数

如果将基类的析构函数声明为虚函数时，由该基类所派生的所有派生类的析构函数都自动成为虚函数，即使派生类的析构函数与基类的析构函数名字不相同。

```
virtual ~A(void); //虚析构函数
virtual ~A(void) = 0; //纯虚析构函数 ，所在的类就为抽象类了
```

如果某个类不包含虚函数，那一般是表示它将不作为一个基类来使用。当一个类不准备作为基类使用时，就不要定义虚析构函数了，因为它会增加一个虚函数表，使得对象的体积翻倍，还有可能降低其可移值性。

定义个函数为虚函数，不代表该函数未被实现，只是为了来实现多态。

定义一个函数为纯虚函数，才表示函数未被实现 ，定义它是为了实现一个接口，起一个规范作用。继承抽象类的派生类要实现这个函数…

#### 6、接口

有时候，我们得提供一些接口给别人使用。接口的作用，就是提供一个与其他系统交互的方法。其他系统无需了解你内部细节，并且也无法了解内部细节，只能通过你提供给外部的接口来与你进行通信。根据c++的特点，我们可以采用纯虚函数的方式来实现。这样做的好处是能够实现封装和多态。

提供给外面使用的接口一般采用纯虚函数

实现接口是通过继承接口的子类来实现的，不同的子类可以实现不同效果，即所谓多态。

#### 7、抽象类与接口

抽象类和接口的区别：

1）类是对对象的抽象，可以把抽象类理解为把类当作对象，抽象成的类叫做抽象类。而接口只是一个行为的规范或规定，微软的自定义接口总是后带able字段，证明其是表述一类类“我能做。。。”。抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中；

2）接口基本上不具备继承的任何具体特点,它仅仅承诺了能够调用的方法;

3）一个类一次可以实现若干个接口，但是只能扩展一个父类；

4）接口可以用于支持回调，而继承并不具备这个特点；

5）抽象类不能被密封；

6）抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的；

7）接口与非抽象类类似，抽象类也必须为在该类的基类列表中列出的接口的所有成员提供它自己的实现。但是，允许抽象类将接口方法映射到抽象方法上；

8）抽象类实现了oop中的一个原则，把可变的与不可变的分离。抽象类和接口就是定义为不可变的，而把可变的座位子类去实现；

9）好的接口定义应该是具有专一功能性的，而不是多功能的，否则造成接口污染。如果一个类只是实现了这个接口的中一个功能，而不得不去实现接口中的其他方法，就叫接口污染；

10）尽量避免使用继承来实现组建功能，而是使用黑箱复用，即对象组合。因为继承的层次增多，造成最直接的后果就是当你调用这个类群中某一类，就必须把他们全部加载到栈中！后果可想而知.（结合堆栈原理理解）。同时，有心的朋友可以留意到微软在构建一个类时，很多时候用到了对象组合的方法。比如http://asp.net中，Page类，有Server Request等属性，但其实他们都是某个类的对象。使用Page类的这个对象来调用另外的类的方法和属性，这个是非常基本的一个设计原则；

11）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法。

#### 8、封装

封装就是通过权限来限制类中的代码外界无法看到更无法更改；

封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！

即

1）公有（ public ）成员可以在类外访问。 　　

2）私有（ private ）成员只能被该类的成员函数访问。 　　

3）保护（ protected ）成员只能被该类的成员函数或派生类的成员函数访问。

#### 9、设计模式的五项原则

1）单一职责原则

单一职责有2 个含义，一个是避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性。

2）接口隔离原则

表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。

该原则观点如下：

①. 一个类对另外一个类的依赖性应当是建立在最小的接口上

②. 客户端程序不应该依赖它不需要的接口方法。

3）开放-封闭原则

open 模块的行为必须是开放的、支持扩展的，而不是僵化的。

closed 在对模块的功能进行扩展时，不应该影响或大规模影响已有的程序模块。一句话概括：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。

核心思想就是对抽象编程，而不对具体编程。

4）替换原则

子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。

主要针对继承的设计原则

①. 父类的方法都要在子类中实现或者重写，并且派生类只实现其抽象类中生命的方法，而不应当给出多余的，方法定义或实现。

②. 在客户端程序中只应该使用父类对象而不应当直接使用子类对象，这样可以实现运行期间绑定。

5）依赖倒置原则

上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。

抽象不能依赖于具体，具体应该要依赖于抽象。