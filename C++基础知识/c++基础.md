### 一、基本语言

#### 1. static 关键字的作用

**a. 全局静态变量**

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。静态存储区，在整个程序运行期间一直存在。

**初始化：**未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

**作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**注：**1. 如果有两个cpp文件声明了同名的全局静态变量，那么他们实际上是独立的两个变量；

        2. 如果在一个头文件中声明，那么每个包含该头文件的cpp都创建一个全局变量，但是他们是彼此独立的；
           3. 声明所有cpp可共享的全局变量，在头文件里声明为extern的：extern int g_; // 注意，不要初始化值！ 
              然后在其中任何一个包含该头文件的cpp中初始化（一次）就好： int g_ = 0; // 初始化一样不要extern修饰，因为extern也是声明性关键字；然后所有包含该头文件的cpp文件都可以用g_这个名字访问相同的一个变量。

**b. 局部静态变量**

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

**内存中的位置：**静态存储区

**初始化：**未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化），且只会初始化一次；

**作用域：**作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

**c. 静态函数**

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static 修饰，那么这个函数只可在本cpp 内使用，不会同其他cpp 中的同名函数引起冲突；

**warning：**不要在头文件中声明static 的全局函数，不要在cpp 内声明非static 的全局函数，如果你要在多个cpp 中复用该函数，就把它的声明提到头文件里去，否则cpp 内部声明需加上static 修饰；

**d. 静态类成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

**e. 类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

#### 2. const关键字的作用

**尽量使用const，而不是#define**

const最常见用途是作为数组的界和switch分情况标号(也可以用枚举符代替)，分类如下：

**常变量：**  const 类型说明符 变量名

**常引用：**  const 类型说明符 &引用名

**常对象：**  类名 const 对象名

**常成员函数：**  类名::fun(形参) const

**常数组：**  类型说明符 const 数组名[大小]

**常指针：**  const 类型说明符* 指针名 ，类型说明符* const 指针名

首先提示的是：在常变量（const 类型说明符 变量名）、常引用（const 类型说明符 &引用名）、常对象（类名 const 对象名）、 常数组（类型说明符 const 数组名[大小]）， const” 与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符）置可以互换。如：
     const int a=5; 与 int const a=5; 等同
     类名 const 对象名 与 const 类名 对象名 等同

**a. 常量**

取代了C中的宏定义，声明时必须进行初始化(!c++类中则不然）。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。―《C++ Program Language》

用const声明的变量虽然增加了分配空间，但是可以保证类型安全。

C标准中，const定义的常量是全局的，C++中视声明位置而定。

**b. 指针和常量**

使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。

所以出现在 * 之前的const是作为基础类型的一部分：

```cpp
char *const cp; //到char的const指针
char const *pc1; //到const char的指针
const char *pc2; //到const char的指针（后两个声明是等同的）
```

pc2的内容不可以改变，但pc2可以指向别的字符串

**注意：**允许把非 const 对象的地址赋给指向 const 对象的指针,不允许把一个 const 对象的地址赋给一个普通的、非 const 对象的指针。

**c. const修饰函数传入参数**

将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。

通常修饰指针参数和引用参数：

```cpp
void Fun( const A *in); //修饰指针型传入参数
void Fun(const A &in); //修饰引用型传入参数
```

**d. 修饰函数返回值**

可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。

**e. const修饰成员函数(c++特性)**

const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；

const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；

const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。

#### 3. C++和C 的区别

设计思想上：
C++是面向对象的语言，而C 是面向过程的结构化编程语言
语法上：
C++具有重载、继承和多态三种特性
C++相比C，增加多许多类型安全的功能，比如强制类型转换、
C++支持范式编程，比如模板类、函数模板等

#### 4. c++中四种cast 转换

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

**a. const_cast**

用于将const 变量转为非const

**b. static_cast**

用于各种隐式转换，比如非const 转const，void*转指针等, static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

**c. dynamic_cast**

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

**d. reinterpret_cast**

几乎什么都可以转，比如将int 转指针，可能会出问题，尽量少用；

**e. 为什么不使用C 的强制转换？**

C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

#### 5. C/C++ 中指针和引用的区别

引用的本质是一个**常指针**

a. 指针有自己的一块空间，而引用只是一个别名；

b. 使用sizeof 看一个指针的大小是4，而引用则是被引用对象的大小；

c. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；

d. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；

e. 可以有const 指针，但是没有const 引用；

f. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；

g. 指针可以有多级指针（**p），而引用至于一级；

h. 指针和引用使用++运算符的意义不一样；

i. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

#### 6. c++中的smart pointer 四个智能指针

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11 支持，并且第一个已经被11 弃用。
**为什么要使用智能指针：**
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

**a. auto_ptr**（c++98 的方案，cpp11 已经抛弃）采用所有权模式。

```cpp
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
```

此时不会报错，p2 剥夺了p1 的所有权，但是当程序运行时访问p1 将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

**b. unique_ptr**（替换auto_ptr）
unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new 创建对象后因为发生异常而忘记调用delete”)特别有用。采用所有权模式，还是上面那个例子

```cpp
unique_ptr<string> p1 (new string ("auto")); //#4
unique_ptr<string> p2； //#5
p2 = p1;//此时会报错！！
```

编译器认为p2=p1 非法，避免了p1 不再指向有效数据的问题。因此，unique_ptr 比auto_ptr更安全。
另外unique_ptr 还有更聪明的地方：当程序试图将一个unique_ptr 赋值给另一个时，如果源unique_ptr 是个临时右值，编译器允许这么做；如果源unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

```cpp
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1; // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
```

其中#1 留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2 不会留下悬挂的unique_ptr，因为它调用unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr 赋给另一个。例如：

```cpp
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

**c. shared_ptr**
shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new 来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0 时，资源会被释放。
shared_ptr 是为了解决auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
**成员函数：**
**use_count()：**返回引用计数的个数
**unique()：**返回是否是独占所有权( use_count 为1)
**swap()：**交换两个shared_ptr 对象(即交换所拥有的对象)
**reset()：**放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
**get()：**返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如

```cpp
shared_ptr<int> sp(new int(1)); 
```

sp 与sp.get()是等价的

**d. weak_ptr**

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合shared_ptr 而引入的一种智能指针来协助shared_ptr 工作, 它只可以从一个shared_ptr 或另一个weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr 是用来解决shared_ptr 相互引用时的死锁问题,
如果说两个shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用lock 函数来获得shared_ptr。

```cpp
class B;
class A {
public:
	shared_ptr<B> pb_;
	~A(){
		cout<<"A delete\n";
	}
};
class B{
public:
	shared_ptr<A> pa_;
	~B(){
		cout<<"B delete\n";
	}
};
void fun(){
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout<<pb.use_count()<<endl;
	cout<<pa.use_count()<<endl;
}
int main(){
	fun();
	return 0;
}
```

可以看到fun 函数中pa ，pb 之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为weak_ptr 就可以了，我们把类A 里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B 的引用开始就只有1，当pb 析构时，B 的计数变为0，B 得到释放，B 释放的同时也会使A 的计数减一，同时pa 析构时使A 的计数减一，那么A 的计数为0，A 得到释放。
**注意：**不能通过weak_ptr 直接访问对象的方法，比如B 对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

可以看到fun 函数中pa ，pb 之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为weak_ptr 就可以了，我们把类A 里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B 的引用开始就只有1，当pb 析构时，B 的计数变为0，B 得到释放，B 释放的同时也会使A 的计数减一，同时pa 析构时使A 的计数减一，那么A 的计数为0，A 得到释放。注意的是我们不能通过weak_ptr 直接访问对象的方法，比如B 对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

#### 7. 数组和指针的区别

| 指针                                                         | 数组                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| 保存数据的地址                                               | 保存数据                             |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据，                       |
| 通常用于动态的数据结构                                       | 通常用于固定数目且数据类型相同的元素 |
| 通过Malloc 分配内存，free 释放内存                           | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数                               | 自身即为数据名                       |

#### 8. 野指针

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。

#### 9. 智能指针的内存泄漏

当两个对象相互使用一个shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

为了解决循环引用导致的内存泄漏，引入了weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

#### 10. 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### 11. inline函数

（1）**特征**：

  ① 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用；

  ② 在函数定义中，函数返回类型前加上关键字inline即把该函数指定为内联。仅将inline放在函数声明前面不起任何作用；

  ③ 定义在**类声明之中（类的内部）**的成员函数将自动地成为内联函数。

（2）**优缺点**：

| 优点                                                         | 缺点                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ① 可以避免调用函数的开销。当函数体比较小的时候，内联函数可以令目标代码更加高效；<br />② 只要内联的函数体较小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。 | ① 由于将对函数的每一个调用都以函数本体替换，所以会增加目标代码的大小，造成代码膨胀。导致程序体积太大，不利于在内存不大的机器上运行；<br />② inline函数无法随着程序库的升级而升级。如果程序库中包含内联函数，一旦内联函数被改变，那么所有用到程序库的客户端程序都要重新编译；<br />③ 很多调试器无法调试内联函数；<br />④ 滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。 |

（3）**编译器对它的实现原理**：

  ① 内联说明(inline specification)对于编译器来说只是一个建议，编译器可以忽略这个建议。

（4）

   ① 强制建议使用const来代替宏常量，使用内联函数来代替宏函数

   ② const和内联函数在进行编译时不仅进行替换，而且还会进行参数类型检测，提高了程序的安全性。

   ③ 内联函数可以是普通函数，也可以是类的成员函数；函数式宏不能作为类的成员函数。

#### 12. friend函数

类的友元函数是定义在类外部，但有权访问此类里面的所有私有成员和保护成员，并且友元函数在类中不属于成员函数。

```
friend <返回类型> <函数名> (<参数列表>);
```

① 类中通过使用关键字friend 来修饰友元函数，但该函数并不是类的成员函数，其声明可以放在类的私有部分，也可放在共有部分。友元函数的定义在类体外实现，不需要加类限定。

② 一个类中的成员函数可以是另外一个类的友元函数，而且一个函数可以是多个类友元函数。

③ 友元函数可以访问类中的私有成员和其他数据，但是访问不可直接使用数据成员，需要通过对对象进行引用。

④ 友元函数在调用上同一般函数一样，不必通过对对象进行引用。



#### 13. sizeof与strlen的区别

（1）sizeof是一个操作符，而strlen是库函数。

（2）sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\0'的字符串作参数。

（3）编译器在编译时就计算出了sizeof的结果，而strlen必须在运行时才能计算出来。

（4）sizeof计算数据类型占内存的大小，strlen计算字符串实际长度。

#### 14. 类调用delete this

1、在非析构函数中调用：

在类的成员函数可以调用delete this，并且delete this之后还可以调用该对象的其他成员，但是有个前提：被调用的方法不涉及这个对象的**数据成员**和**虚函数**。

当一个类对象声明时，系统会为其分配内存空间。在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。

当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。

为什么会出现这种情况？delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

2、在析构函数中调用：

delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。

#### 15. 静态局部变量的初始化问题。

首先，静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。