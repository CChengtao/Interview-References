### 一、基本语言

#### 1. static 关键字的作用

**a. 全局静态变量**

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。静态存储区，在整个程序运行期间一直存在。

**初始化：**未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

**作用域：**全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**b. 局部静态变量**

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

**内存中的位置：**静态存储区

**初始化：**未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

**作用域：**作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

**c. 静态函数**

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static 修饰，那么这个函数只可在本cpp 内使用，不会同其他cpp 中的同名函数引起冲突；

**warning：**不要再头文件中声明static 的全局函数，不要在cpp 内声明非static 的全局函数，如果你要在多个cpp 中复用该函数，就把它的声明提到头文件里去，否则cpp 内部声明需加上static 修饰；

**d. 静态类成员**

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

**e. 类的静态函数**

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

#### 2. const关键字的作用

**尽量使用const，而不是#define**

const最常见用途是作为数组的界和switch分情况标号(也可以用枚举符代替)，分类如下：

**常变量：**  const 类型说明符 变量名

**常引用：**  const 类型说明符 &引用名

**常对象：**  类名 const 对象名

**常成员函数：**  类名::fun(形参) const

**常数组：**  类型说明符 const 数组名[大小]

**常指针：**  const 类型说明符* 指针名 ，类型说明符* const 指针名

首先提示的是：在常变量（const 类型说明符 变量名）、常引用（const 类型说明符 &引用名）、常对象（类名 const 对象名）、 常数组（类型说明符 const 数组名[大小]）， const” 与 “类型说明符”或“类名”（其实类名是一种自定义的类型说明符）置可以互换。如：
     const int a=5; 与 int const a=5; 等同
     类名 const 对象名 与 const 类名 对象名 等同

**a. 常量**

取代了C中的宏定义，声明时必须进行初始化(!c++类中则不然）。const限制了常量的使用方式，并没有描述常量应该如何分配。如果编译器知道了某const的所有使用，它甚至可以不为该const分配空间。最简单的常见情况就是常量的值在编译时已知，而且不需要分配存储。―《C++ Program Language》

用const声明的变量虽然增加了分配空间，但是可以保证类型安全。

C标准中，const定义的常量是全局的，C++中视声明位置而定。

**b. 指针和常量**

使用指针时涉及到两个对象：该指针本身和被它所指的对象。将一个指针的声明用const“预先固定”将使那个对象而不是使这个指针成为常量。要将指针本身而不是被指对象声明为常量，必须使用声明运算符*const。

所以出现在 * 之前的const是作为基础类型的一部分：

```cpp
char *const cp; //到char的const指针
char const *pc1; //到const char的指针
const char *pc2; //到const char的指针（后两个声明是等同的）
```

pc2的内容不可以改变，但pc2可以指向别的字符串

**注意：**允许把非 const 对象的地址赋给指向 const 对象的指针,不允许把一个 const 对象的地址赋给一个普通的、非 const 对象的指针。

**c. const修饰函数传入参数**

将函数传入参数声明为const，以指明使用这种参数仅仅是为了效率的原因，而不是想让调用函数能够修改对象的值。同理，将指针参数声明为const，函数将不修改由这个参数所指的对象。

通常修饰指针参数和引用参数：

```cpp
void Fun( const A *in); //修饰指针型传入参数
void Fun(const A &in); //修饰引用型传入参数
```

**d. 修饰函数返回值**

可以阻止用户修改返回值。返回值也要相应的付给一个常量或常指针。

**e. const修饰成员函数(c++特性)**

const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数；

const对象的成员是不能修改的，而通过指针维护的对象确实可以修改的；

const成员函数不可以修改对象的数据，不管对象是否具有const性质。编译时以是否修改成员数据为依据进行检查。

#### 3. C++和C 的区别

设计思想上：
C++是面向对象的语言，而C 是面向过程的结构化编程语言
语法上：
C++具有重载、继承和多态三种特性
C++相比C，增加多许多类型安全的功能，比如强制类型转换、
C++支持范式编程，比如模板类、函数模板等

#### 4. c++中四种cast 转换

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

**a. const_cast**

用于将const 变量转为非const

**b. static_cast**

用于各种隐式转换，比如非const 转const，void*转指针等, static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

**c. dynamic_cast**

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
向上转换：指的是子类向基类的转换
向下转换：指的是基类向子类的转换
它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

**d. reinterpret_cast**

几乎什么都可以转，比如将int 转指针，可能会出问题，尽量少用；

**e. 为什么不使用C 的强制转换？**

C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

#### 5. C/C++ 中指针和引用的区别

引用的本质是一个**常指针**

a. 指针有自己的一块空间，而引用只是一个别名；

b. 使用sizeof 看一个指针的大小是4，而引用则是被引用对象的大小；

c. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；

d. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；

e. 可以有const 指针，但是没有const 引用；

f. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；

g. 指针可以有多级指针（**p），而引用至于一级；

h. 指针和引用使用++运算符的意义不一样；

i. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

#### 6. c++中的smart pointer 四个智能指针

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11 支持，并且第一个已经被11 弃用。
**为什么要使用智能指针：**
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

**a. auto_ptr**（c++98 的方案，cpp11 已经抛弃）采用所有权模式。

```cpp
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr 不会报错.
```

此时不会报错，p2 剥夺了p1 的所有权，但是当程序运行时访问p1 将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！

**b. unique_ptr**（替换auto_ptr）
unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new 创建对象后因为发生异常而忘记调用delete”)特别有用。采用所有权模式，还是上面那个例子

```cpp
unique_ptr<string> p1 (new string ("auto")); //#4
unique_ptr<string> p2； //#5
p2 = p1;//此时会报错！！
```

编译器认为p2=p1 非法，避免了p1 不再指向有效数据的问题。因此，unique_ptr 比auto_ptr更安全。
另外unique_ptr 还有更聪明的地方：当程序试图将一个unique_ptr 赋值给另一个时，如果源unique_ptr 是个临时右值，编译器允许这么做；如果源unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

```cpp
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1; // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You")); // #2 allowed
```

其中#1 留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2 不会留下悬挂的unique_ptr，因为它调用unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr 赋给另一个。例如：

```cpp
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

**c. shared_ptr**
shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new 来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr 来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0 时，资源会被释放。
shared_ptr 是为了解决auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
**成员函数：**
**use_count()：**返回引用计数的个数
**unique()：**返回是否是独占所有权( use_count 为1)
**swap()：**交换两个shared_ptr 对象(即交换所拥有的对象)
**reset()：**放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
**get()：**返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如

```cpp
shared_ptr<int> sp(new int(1)); 
```

sp 与sp.get()是等价的

**d. weak_ptr**

weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合shared_ptr 而引入的一种智能指针来协助shared_ptr 工作, 它只可以从一个shared_ptr 或另一个weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr 是用来解决shared_ptr 相互引用时的死锁问题,
如果说两个shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用lock 函数来获得shared_ptr。

```cpp
class B;
class A {
public:
	shared_ptr<B> pb_;
	~A(){
		cout<<"A delete\n";
	}
};
class B{
public:
	shared_ptr<A> pa_;
	~B(){
		cout<<"B delete\n";
	}
};
void fun(){
	shared_ptr<B> pb(new B());
	shared_ptr<A> pa(new A());
	pb->pa_ = pa;
	pa->pb_ = pb;
	cout<<pb.use_count()<<endl;
	cout<<pa.use_count()<<endl;
}
int main(){
	fun();
	return 0;
}
```

可以看到fun 函数中pa ，pb 之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为weak_ptr 就可以了，我们把类A 里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B 的引用开始就只有1，当pb 析构时，B 的计数变为0，B 得到释放，B 释放的同时也会使A 的计数减一，同时pa 析构时使A 的计数减一，那么A 的计数为0，A 得到释放。
**注意：**不能通过weak_ptr 直接访问对象的方法，比如B 对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

可以看到fun 函数中pa ，pb 之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为weak_ptr 就可以了，我们把类A 里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B 的引用开始就只有1，当pb 析构时，B 的计数变为0，B 得到释放，B 释放的同时也会使A 的计数减一，同时pa 析构时使A 的计数减一，那么A 的计数为0，A 得到释放。注意的是我们不能通过weak_ptr 直接访问对象的方法，比如B 对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();

#### 7. 数组和指针的区别

| 指针                                                         | 数组                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| 保存数据的地址                                               | 保存数据                             |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 | 直接访问数据，                       |
| 通常用于动态的数据结构                                       | 通常用于固定数目且数据类型相同的元素 |
| 通过Malloc 分配内存，free 释放内存                           | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名函数                               | 自身即为数据名                       |

#### 8. 野指针

野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。

#### 9. 智能指针的内存泄漏

当两个对象相互使用一个shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

为了解决循环引用导致的内存泄漏，引入了weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

#### 10. 为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数？

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### 11. inline函数

（1）**特征**：

  ① 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用；

  ① 在函数定义中，函数返回类型前加上关键字inline即把该函数指定为内联。仅将inline放在函数声明前面不起任何作用；

  ② 定义在类声明之中的成员函数将自动地成为内联函数。

（2）**优缺点**：

| 优点                                                         | 缺点                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ① 可以避免调用函数的开销。当函数体比较小的时候，内联函数可以令目标代码更加高效；<br />② 只要内联的函数体较小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。 | ① 由于将对函数的每一个调用都以函数本体替换，所以会增加目标代码的大小，造成代码膨胀。导致程序体积太大，不利于在内存不大的机器上运行；<br />② inline函数无法随着程序库的升级而升级。如果程序库中包含内联函数，一旦内联函数被改变，那么所有用到程序库的客户端程序都要重新编译；<br />③ 很多调试器无法调试内联函数；<br />④ 滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减，这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。 |

（3）**编译器对它的实现原理**：

  ① 内联说明(inline specification)对于编译器来说只是一个建议，编译器可以忽略这个建议。