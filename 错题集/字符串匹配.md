

#### 一、Brute Force算法

 给定主串和模式串如下（假定字符串只包含26个小写字母） 

| 主串   | a    | b    | b    | c    | e    | f    | g    | h    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 | b    | c    | e    |      |      |      |      |      |

第一轮，从主串的首位置开始，把主串和模式串的字符逐个比较：

| 主串   | $\color{#FF3030}{a}$ | b    | b    | c    | e    | f    | g    | h    |
| ------ | -------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 | $\color{#FF3030}{b}$ | c    | e    |      |      |      |      |      |

显然，主串的首位字符是a，模式串的首位字符是b，两者并不匹配。

第二轮，把模式串后移一位，从主串的第二位开始，把主串和模式串的字符逐个比较：

| 主串   | a    | $\color{#FF3030}{b}$ | b    | c    | e    | f    | g    | h    |
| ------ | ---- | -------------------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 |      | $\color{#FF3030}{b}$ | c    | e    |      |      |      |      |

主串的第二位字符是b，模式串的第二位字符也是b，两者匹配，继续比较：

| 主串   | a    | $\color{#FF3030}{b}$ | $\color{#FFFF00}{b}$ | c    | e    | f    | g    | h    |
| ------ | ---- | -------------------- | -------------------- | ---- | ---- | ---- | ---- | ---- |
| 模式串 |      | $\color{#FF3030}{b}$ | $\color{#FFFF00}{c}$ | e    |      |      |      |      |

主串的第三位字符是b，模式串的第三位字符也是c，两者并不匹配。

第三轮，我们把模式串再次后移一位，从主串的第三位开始，把主串和模式串的字符逐个比较：

| 主串   | a    | b    | $\color{#FF3030}{b}$ | c    | e    | f    | g    | h    |
| ------ | ---- | ---- | -------------------- | ---- | ---- | ---- | ---- | ---- |
| 模式串 |      |      | $\color{#FF3030}{b}$ | c    | e    |      |      |      |

 主串的第三位字符是b，模式串的第三位字符也是b，两者匹配，继续比较： 

| 主串   | a    | b    | $\color{#FF3030}{b}$ | $\color{#FFFF00}{c}$ | e    | f    | g    | h    |
| ------ | ---- | ---- | -------------------- | -------------------- | ---- | ---- | ---- | ---- |
| 模式串 |      |      | $\color{#FF3030}{b}$ | $\color{#FFFF00}{c}$ | e    |      |      |      |

主串的第四位字符是c，模式串的第四位字符也是c，两者匹配，继续比较：

| 主串   | a    | b    | $\color{#FF3030}{b}$ | $\color{#FFFF00}{c}$ | $\color{#FF00FF}{e}$ | f    | g    | h    |
| ------ | ---- | ---- | -------------------- | -------------------- | -------------------- | ---- | ---- | ---- |
| 模式串 |      |      | $\color{#FF3030}{b}$ | $\color{#FFFF00}{c}$ | $\color{#FF00FF}{e}$ |      |      |      |

主串的第五位字符是e，模式串的第五位字符也是e，两者匹配，比较完成！

以上就是暴力算法(Brute Force)的解法。

以上算法能够解决问题，但是在某些极端的情况下算法的效率很低。如下例：

| 主串   | a    | a    | a    | ...  | a    | a    | a    | b    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 | a    | a    | a    | b    |      |      |      |      |

对于上述例子，在每一轮进行字符匹配时，模式串的前三个字符a都和主串中的字符相匹配，一直检查到模式串最后一个字符b，才发现不匹配。

这样一来，两个字符串在每一轮都需要白白比较4次，显然非常浪费。

假设主串的长度是m，模式串的长度是n，那么在这种极端情况下，BF算法的最坏时间复杂度是O(mn)。

#### 二、Rabin-Karp算法

用过哈希表的朋友们都知道，每一个字符串都可以通过某种哈希算法，转换成一个整型数，这个整型数就是hashcode：

hashcode = hash（string）

显然，相对于逐个字符比较两个字符串，仅比较两个字符串的hashcode要容易得多。

|   字符串    | hash函数 | hash值 |
| :---------: | :------: | :----: |
| sssddddeeer |    →     | 39434  |
| sssddddeaar |    →     |  4358  |

 给定主串和模式串如下（假定字符串只包含26个小写字母） 

| 主串   | a    | b    | b    | c    | e    | f    | g    | h    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 | b    | c    | e    |      |      |      |      |      |

**第一步，我们需要生成模式串的hash值。**

hash函数多种多样，比如：

**按位相加**

这是最简单的方法，我们可以把a当做1，b当做2，c当做3......然后把字符串的所有字符相加，相加结果就是它的hashcode。
$$
bce = 2 + 3 + 5 = 10
$$
但是，这个算法虽然简单，却很可能产生hash冲突，比如bce、bec、cbe的hash值是一样的。

**转换成26进制数**

既然字符串只包含26个小写字母，那么我们可以把每一个字符串当成一个26进制数来计算。

$$
bce = 2*(26^2) + 3*26 + 5 = 1435
$$
这样做的好处是大幅减少了hash冲突，缺点是计算量较大，而且有可能出现超出整型范围的情况，需要对计算结果进行取模。

为了方便演示，后续我们采用的是按位相加的hash算法，所以bce的hash值是10。

**第二步，生成主串当中第一个等模式串的hash值。**

由于主串通常要长于模式串，把整个主串转化成hash值是没有意义的，只有比较主串当中和模式串等长的子串才有意义。

因此，我们首先生成主串中第一个和模式串等长的子串hash值，

$$
abb = 1 + 2 + 2 = 5
$$
**第三步，比较两个hash值。**

显然，$ 5！=10 $，说明模式串和第一个子串不匹配，我们继续下一轮比较。

**第四步，生成主串当中第二个等长子串的值。**
$$
bbc = 2 + 2 + 3 = 7
$$
**第五步，比较两个hash值。**

显然，$ 7！=10 $，说明模式串和第二个子串不匹配，我们继续下一轮比较。

**第六步，生成主串当中第三个等长子串的hash值。**
$$
bce= 2 + 3 + 5 = 10：
$$
**第七步，比较两个hash值。**

显然，10 ==10，两个hash值相等！这是否说明两个字符串也相等呢？

别高兴的太早，由于存在hash冲突的可能，我们还需要进一步验证。

**第八步，逐个字符比较两字符串。**

hash值的比较只是初步验证，之后我们还需要像BF算法那样，对两个字符串逐个字符比较，最终判断出两个字符串匹配。

最后得出结论，模式串bce是主串abbcefgh的子串，第一次出现的下标是2。

**注：每次hash的时间复杂度是O(n)，如果把全全部子串都进行hash，总的时间复杂度和BF算法一致。因此需要对函数函数进行适当改进。**

对于给定的主串和模式串：

| 主串   | a    | b    | b    | c    | e    | f    | g    | h    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 | b    | c    | e    |      |      |      |      |      |

$$
hash(abb)=5
$$

没有必要把子串的字符重新进行累加运算，而是可以采用一个更简单的方法。由于新子串的前面少了一个a，后面多了一个c，所以：
$$
hash(bbc)=hash(abb)-hash(a)+hash(c)=5-1+3=7
$$
因此，RK算法计算单个子串的时间复杂度是O(m)，但由于后续子串的hash是增量计算，所以总的时间复杂度是O(n)。

相比于BF算法，RK算法采用hash值进行筛选，免去了许多五位的字符串比较，所以时间复杂度大大降低了。当每一次hash冲突的时候，RK算法都要对子串和模式串逐个字符进行比较，如果冲突太多，RK算法会退化成BF算法。

#### 三、Knuth-Morris-Pratt 算法

 给定主串和模式串如下（假定字符串只包含26个小写字母） 

| 主串   | b    | b    | c    |      | a    | b    | c    | d    | a    | b    |      | a    | b    | c    | d    | a    | b    | c    | d    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 模式串 | a    | b    | c    | d    | a    | b    | d    |      |      |      |      |      |      |      |      |      |      |      |      |

```cpp
bool kmp() {
    int sLen = sOrder.size(), tLen = tOrder.size();
    vector <int> fail(tOrder.size(), -1);
    for (int i = 1, j = -1; i < tLen; ++i) {
        while (j != -1 && tOrder[i] != tOrder[j + 1]) j = fail[j];
        if (tOrder[i] == tOrder[j + 1]) ++j;
        fail[i] = j;
    }
    for (int i = 0, j = -1; i < sLen; ++i) {
        while (j != -1 && sOrder[i] != tOrder[j + 1]) j = fail[j];
        if (sOrder[i] == tOrder[j + 1]) ++j;
        if (j == tLen - 1) return true;
    }
    return false;
}
```

 https://blog.csdn.net/daaikuaichuan/article/details/80719203 

#### 四、BM算法

