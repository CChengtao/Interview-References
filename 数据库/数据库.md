#### 1、数据库事务以及四个特性

事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS 中最基础的单位，事务不可分割。

事务具有4 个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

1. **原子性（Atomicity）**：指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2. **一致性（Consistency）**：指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A 和用户B 两者的钱加起来一共是5000，那么不管A 和B 之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3. **隔离性（Isolation）**：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1 和T2，在事务T1 看来，T2 要么在T1 开始之前就已经结束，要么在T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
    多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
    
    不同的隔离级别：
    
    **Read Uncommitted**（读取未提交）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
    **Read Committed**（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
    **Repeated Read**（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
    **Serialization**（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

4. **持久性**（Durability）：指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
   
   例如我们在使用JDBC 操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。
   

多事务的并发进行一般会造成以下几个问题:

1. 脏读(Dirty Read)

   当一个事务读取另一个事务尚未提交的修改时，产生脏读。

   同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。

2. 非重复读(Nonrepeatable Read)

   一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。

3. 幻像读(Phantom Reads) 

   事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。

   当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。

4. 丢失修改(Lost Update)

   第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。

   第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。

#### 2、数据库的索引，多加索引一定会好吗？

数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中**一列**或**多列**的值进行排序的一种结构。

数据库在执行一条SQL语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。

**优点**：

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**缺点**：

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

**添加索引原则**：

在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

定义为text、image 和bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

#### 3、什么是索引？

索引是一种数据结构，可以帮助我们快速的进行数据的查找。

#### 4、索引是个什么样的数据结构呢?

索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，而我们经常使用的InnoDB存储引擎的默认索引实现为:B+树索引。

#### 5、Hash索引和B+树所有有什么区别或者说优劣呢?

hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据；B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。

区别：

1. hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似)，天然支持范围。
2. hash索引不支持使用索引进行排序，原理同上。
3. hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。
4. hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
5. hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。

因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引。

#### 6、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，什么是聚簇索引?

在B+树的索引中，叶子节点可能存储了当前的key值（B+树），也可能存储了当前的key值以及整行的数据（B-树），这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

#### 7、非聚簇索引一定会回表查询吗?

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。

举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。

#### 8、在建立索引的时候,都有哪些需要考虑的因素呢?

建立索引的时候一般要考虑到字段的使用**频率**，经常作为条件进行查询的字段比较适合。如果需要建立联合索引的话，还需要考虑联合索引中的**顺序**。此外也要考虑其他方面，比如防止过多的所有对表造成太大的压力。这些都和实际的表结构以及查询方式有关。

#### 9、联合索引是什么?为什么需要注意联合索引中的顺序?

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为：

MySQL使用索引时需要索引有序，假设现在建立了"name,age,school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

#### 10、数据库锁

当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。

从锁的类别上来讲，有共享锁和排他锁。

共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。

排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁、页级锁和表级锁。

他们的加锁开销从大大小，并发能力也是从大到小。

#### 11、数据库三个范式

第一范式: 每个列都不可以再拆分.。

第二范式: 非主键列完全依赖于主键，而不能是依赖于主键的一部分。

第三范式: 非主键列只依赖于主键，不依赖于其他非主键。

在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由，比如性能。 事实上我们经常会为了性能而妥协数据库的设计。

#### 12、MySQL中的varchar和char有什么区别？

char是一个定长字段,假如申请了char(10)的空间，那么无论实际存储多少内容。该字段都占用10个字符，而varchar是变长的，也就是说申请的只是最大长度，占用的空间为实际字符长度+1，最后一个字符存储使用了多长的空间。

在检索效率上来讲，char > varchar，因此在使用中，如果确定某个字段的值的长度，可以使用char，否则应该尽量使用varchar。例如存储用户MD5加密后的密码，则应该使用char。

#### 13、varchar(10)和int(10)代表什么含义?

varchar的10代表了申请的空间长度，也是可以存储的数据的最大长度，而int的10只是代表了展示的长度，不足10位以0填充。也就是说，int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的，只是在展示时按照长度展示。

#### 14、SQL优化方法有哪些？

1. 在表中建立索引，优先考虑where、group by使用到的字段。

2. 尽量避免使用select *，返回无用的字段会降低查询效率。

   ```sql
   SELECT * FROM t 
   ```

   优化方式：使用具体的字段代替*，只返回使用到的字段。

3. 尽量避免使用in 和not in，会导致数据库引擎放弃索引进行全表扫描。

   ```sql
   SELECT * FROM t WHERE id IN (2,3)
   SELECT * FROM t1 WHERE username IN (SELECT username FROM t2)
   ```

   优化方式：如果是连续数值，可以用between代替。

   ```sql
   SELECT * FROM t WHERE id BETWEEN 2 AND 3
   ```

   如果是子查询，可以用exists代替。

   ```sql
   SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE t1.username = t2.username)
   ```

4. 尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。

   ```sql
   SELECT * FROM t WHERE id = 1 OR id = 3
   ```

   优化方式：可以用union代替or。

   ```sql
   SELECT * FROM t WHERE id = 1
   UNION
   SELECT * FROM t WHERE id = 3
   ```

5. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。

   ```sql
   SELECT * FROM t WHERE username LIKE '%li%'
   ```

   优化方式：尽量在字段后面使用模糊查询。

   ```sql
   SELECT * FROM t WHERE username LIKE 'li%'
   ```

6. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。

   ```sql
   SELECT * FROM t WHERE score IS NULL
   ```

   优化方式：可以给字段添加默认值0，对0值进行判断。

   ```sql
   SELECT * FROM t WHERE score = 0
   ```

7. 尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。

   ```sql
   SELECT * FROM t2 WHERE score/10 = 9
   SELECT * FROM t2 WHERE SUBSTR(username,1,2) = 'li'
   ```

   优化方式：可以将表达式、函数操作移动到等号右侧。

   ```sql
   SELECT * FROM t2 WHERE score = 10*9
   SELECT * FROM t2 WHERE username LIKE 'li%'
   ```

8. 当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。

   ```sql
   SELECT * FROM t WHERE 1=1
   ```

   优化方式：用代码拼装sql时进行判断，没where加where，有where加and。

#### 15、数据库如何实现隔离？

（1）MVCC(多版本并发控制)

MVCC 是一种多版本并发控制机制，是MySQL 的InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。MVCC 是通过保存数据在某个时间点的快照来实现该机制，其在每行记录后面保存两个隐藏的列，分别保存这个行的创建版本号和删除版本号，然后Innodb 的MVCC 使用到的快照存储在Undo 日志中，该日志通过回滚指针把一个数据行所有快照连接起来。

（2）锁

1. Shared Locks(共享锁/S锁)

   若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

2. Exclusive Locks(排它锁/X锁)

   若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。

   注意：排他锁会阻止其它事务再对其锁定的数据加读或写的锁，但是不加锁的就没办法控制了。

3. Record Locks(行锁)

   行锁，顾名思义，是加在**索引行**上的锁。比如select * from user where id=1 and id=10 for update，就会在id=1和id=10的索引行上加Record Lock。

4. Gap Locks(间隙锁)

   间隙锁，它会锁住两个索引之间的区域。比如select * from user where id>1 and id<10 for update，就会在id为(1,10)的索引区间上加Gap Lock。

5. Next-Key Locks(间隙锁)

   也叫间隙锁，它是Record Lock + Gap Lock形成的一个闭区间锁。比如select * from user where id>=1 and id<=10 for update，就会在id为[1,10]的索引闭区间上加Next-Key Lock。

这样组合起来就有：行级共享锁，表级共享锁，行级排它锁，表级排它锁。

**什么时候加锁？**

在数据库增删改查四种操作中，insert、delete和update都是会加排它锁(Exclusive Locks)的，而select只有显式声明才会加锁:

1. select: 即最常用的查询，是不加任何锁的
2. select ... lock in share mode: 会加共享锁(Shared Locks)
3. select ... for update: 会加排它锁



